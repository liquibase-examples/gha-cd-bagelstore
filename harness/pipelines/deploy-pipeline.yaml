pipeline:
  name: Deploy Bagel Store
  identifier: Deploy_Bagel_Store
  projectIdentifier: bagel_store_demo
  orgIdentifier: default
  tags:
    demo_id: <+env.variables.demo_id>
    deployment_type: coordinated_db_app

  # Pipeline-level variables
  # Note: Infrastructure-specific values (RDS endpoint, App Runner ARNs, etc.)
  # are now provided via Harness Environment Variables (configured by Terraform)
  variables:
    - name: VERSION
      type: String
      description: Git tag version (e.g., v1.0.0)
      required: true
      value: <+input>

    - name: GITHUB_ORG
      type: String
      description: GitHub organization name
      required: true
      value: <+input>.execute-once

  # Deployment stages for all four environments
  stages:
    # ===== STAGE 1: Deploy to Dev (Automatic) =====
    - stage:
        name: Deploy to Dev
        identifier: Deploy_to_Dev
        description: Automatically deploy database and application to dev environment
        type: Deployment
        tags:
          environment: dev

        spec:
          deploymentType: CustomDeployment

          # Service definition
          service:
            serviceRef: bagel_store
            serviceInputs:
              serviceDefinition:
                type: CustomDeployment
                spec:
                  artifacts:
                    primary:
                      primaryArtifactRef: docker_image
                      sources:
                        - identifier: docker_image
                          type: DockerRegistry
                          spec:
                            connectorRef: github_container_registry
                            imagePath: <+pipeline.variables.GITHUB_ORG>/bagel-store
                            tag: <+pipeline.variables.VERSION>

          # Environment configuration
          environment:
            environmentRef: dev
            deployToAll: false
            infrastructureDefinitions:
              - identifier: dev_infrastructure

          # Execution steps
          execution:
            steps:
              # Step 1: Fetch changelog artifact from GitHub Packages
              - step:
                  type: ShellScript
                  name: Fetch Changelog Artifact
                  identifier: Fetch_Changelog_Artifact
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          echo "=== Fetching Changelog Artifact ==="
                          echo "Version: <+pipeline.variables.VERSION>"
                          echo "GitHub Org: <+pipeline.variables.GITHUB_ORG>"

                          # Create working directory
                          mkdir -p /tmp/changelog
                          cd /tmp/changelog

                          # Download changelog zip from GitHub Packages
                          # Note: GitHub Packages uses Maven format for generic packages
                          PACKAGE_URL="https://maven.pkg.github.com/<+pipeline.variables.GITHUB_ORG>/harness-gha-bagelstore/bagel-store-changelog/<+pipeline.variables.VERSION>/bagel-store-changelog-<+pipeline.variables.VERSION>.zip"

                          echo "Downloading from: $PACKAGE_URL"

                          curl -L \
                            -H "Authorization: token <+secrets.getValue('github_pat')>" \
                            -o changelog.zip \
                            "$PACKAGE_URL"

                          # Extract changelog
                          unzip -q changelog.zip -d .

                          echo "Changelog extracted successfully"
                          ls -la
                    environmentVariables: []
                    outputVariables: []
                  timeout: 5m

              # Step 2: Update database with Liquibase
              - step:
                  type: ShellScript
                  name: Update Database
                  identifier: Update_Database
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          echo "=== Updating Database with Liquibase ==="
                          echo "Environment: <+env.variables.environment>"
                          echo "Deployment Target: ${DEPLOYMENT_TARGET:-aws}"
                          echo "Demo ID: <+env.variables.demo_id>"

                          # Determine deployment target (default to 'aws' if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # ===== AWS MODE =====
                            echo "Using AWS RDS endpoint: <+env.variables.rds_endpoint>"

                            docker run --rm \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')> \
                              -e AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')> \
                              -e AWS_REGION=<+env.variables.aws_region> \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=<+env.variables.jdbc_url> \
                              --username='${awsSecretsManager:<+env.variables.demo_id>/rds/username}' \
                              --password='${awsSecretsManager:<+env.variables.demo_id>/rds/password}' \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update

                          else
                            # ===== LOCAL MODE =====
                            echo "Using local PostgreSQL container: postgres-<+env.variables.environment>"

                            # Connect to Docker Compose network
                            docker run --rm \
                              --network harness-gha-bagelstore_bagel-network \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=jdbc:postgresql://postgres-<+env.variables.environment>:5432/<+env.variables.environment> \
                              --username=postgres \
                              --password=postgres \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          fi

                          echo "✅ Database update completed successfully"
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              # Step 3: Deploy application to App Runner
              - step:
                  type: ShellScript
                  name: Deploy Application
                  identifier: Deploy_Application
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          echo "=== Deploying Application ==="
                          echo "Environment: <+env.variables.environment>"
                          echo "Version: <+pipeline.variables.VERSION>"
                          echo "Deployment Target: ${DEPLOYMENT_TARGET:-aws}"

                          # Determine deployment target (default to 'aws' if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # ===== AWS MODE =====
                            echo "Deploying to App Runner"

                            export AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')>
                            export AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')>
                            export AWS_DEFAULT_REGION=<+env.variables.aws_region>

                            SERVICE_ARN="<+env.variables.app_runner_service_arn>"

                            aws apprunner update-service \
                              --service-arn "$SERVICE_ARN" \
                              --source-configuration "{
                                \"ImageRepository\": {
                                  \"ImageIdentifier\": \"ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:<+pipeline.variables.VERSION>\",
                                  \"ImageRepositoryType\": \"ECR_PUBLIC\",
                                  \"ImageConfiguration\": {
                                    \"Port\": \"5000\",
                                    \"RuntimeEnvironmentVariables\": {
                                      \"DATABASE_URL\": \"postgresql://\${awsSecretsManager:<+env.variables.demo_id>/rds/username}:\${awsSecretsManager:<+env.variables.demo_id>/rds/password}@<+env.variables.rds_address>:<+env.variables.rds_port>/<+env.variables.database_name>\",
                                      \"FLASK_ENV\": \"production\",
                                      \"APP_VERSION\": \"<+pipeline.variables.VERSION>\"
                                    }
                                  }
                                }
                              }" \
                              --region <+env.variables.aws_region>

                          else
                            # ===== LOCAL MODE =====
                            echo "Deploying to Docker Compose"

                            # Navigate to repository root
                            cd $HOME/workspace/harness-gha-bagelstore

                            # Ensure .env file exists
                            if [ ! -f .env ]; then
                              echo "Creating .env from template"
                              cp .env.example .env
                            fi

                            # Update version in .env file
                            ENV_UPPER=$(echo "<+env.variables.environment>" | tr '[:lower:]' '[:upper:]')
                            ENV_VAR="VERSION_${ENV_UPPER}"
                            NEW_VERSION="<+pipeline.variables.VERSION>"

                            echo "Updating ${ENV_VAR}=${NEW_VERSION} in .env"

                            if grep -q "^${ENV_VAR}=" .env; then
                              # Update existing line (macOS compatible)
                              sed -i.bak "s/^${ENV_VAR}=.*/${ENV_VAR}=${NEW_VERSION}/" .env
                              rm -f .env.bak
                            else
                              # Add new line
                              echo "${ENV_VAR}=${NEW_VERSION}" >> .env
                            fi

                            # Show current .env state
                            echo "Current .env configuration:"
                            grep "^VERSION_" .env || echo "No VERSION variables found"

                            # Pull new image version
                            docker compose -f docker-compose-demo.yml pull app-<+env.variables.environment>

                            # Restart specific service with new version
                            docker compose -f docker-compose-demo.yml up -d --no-deps app-<+env.variables.environment>
                          fi

                          echo "✅ Application deployment completed"
                    environmentVariables: []
                    outputVariables:
                      - name: SERVICE_URL
                        type: String
                        value: service_url
                  timeout: 10m

              # Step 4: Health check
              - step:
                  type: ShellScript
                  name: Health Check
                  identifier: Health_Check
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          echo "=== Performing Health Check ==="
                          echo "Deployment Target: ${DEPLOYMENT_TARGET:-aws}"

                          # Determine deployment target (default to 'aws' if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # ===== AWS MODE =====
                            SERVICE_URL="<+env.variables.app_runner_service_url>"
                            HEALTH_URL="https://${SERVICE_URL}/health"
                            VERSION_URL="https://${SERVICE_URL}/version"
                          else
                            # ===== LOCAL MODE =====
                            case "<+env.variables.environment>" in
                              dev)     PORT=5001 ;;
                              test)    PORT=5002 ;;
                              staging) PORT=5003 ;;
                              prod)    PORT=5004 ;;
                            esac
                            HEALTH_URL="http://localhost:${PORT}/health"
                            VERSION_URL="http://localhost:${PORT}/version"
                          fi

                          echo "Health check URL: $HEALTH_URL"

                          # Wait for service to be ready (max 5 minutes)
                          MAX_ATTEMPTS=30
                          ATTEMPT=0

                          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS..."

                            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

                            if [ "$HTTP_CODE" = "200" ]; then
                              echo "✅ Health check passed!"

                              # Verify version
                              VERSION_RESPONSE=$(curl -s "$VERSION_URL" || echo "{}")
                              echo "Version info: $VERSION_RESPONSE"

                              DEPLOYED_VERSION=$(echo "$VERSION_RESPONSE" | jq -r '.version // "unknown"')
                              EXPECTED_VERSION="<+pipeline.variables.VERSION>"

                              if [ "$DEPLOYED_VERSION" = "$EXPECTED_VERSION" ]; then
                                echo "✅ Version verified: $DEPLOYED_VERSION"
                              else
                                echo "⚠️  Version mismatch: expected $EXPECTED_VERSION, got $DEPLOYED_VERSION"
                              fi

                              exit 0
                            fi

                            echo "Health check returned HTTP $HTTP_CODE, retrying in 10s..."
                            sleep 10
                            ATTEMPT=$((ATTEMPT + 1))
                          done

                          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
                          exit 1
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

            # Rollback steps (if deployment fails)
            rollbackSteps: []

        # Failure strategy
        failureStrategies:
          - onFailure:
              errors:
                - AllErrors
              action:
                type: Abort

        # Execute when
        when:
          pipelineStatus: Success

    # ===== STAGE 2: Deploy to Test (Manual Approval Required) =====
    - stage:
        name: Deploy to Test
        identifier: Deploy_to_Test
        description: Deploy database and application to test environment (requires approval)
        type: Deployment
        tags:
          environment: test

        spec:
          deploymentType: CustomDeployment

          service:
            useFromStage:
              stage: Deploy_to_Dev

          environment:
            environmentRef: test
            deployToAll: false
            infrastructureDefinitions:
              - identifier: test_infrastructure

          execution:
            steps:
              # Manual approval gate
              - step:
                  type: HarnessApproval
                  name: Approve Test Deployment
                  identifier: Approve_Test_Deployment
                  spec:
                    approvalMessage: "Please review and approve deployment to TEST environment.\n\nVersion: <+pipeline.variables.VERSION>\nDemo ID: <+env.variables.demo_id>\n\nChanges will be applied to test database and application."
                    includePipelineExecutionHistory: true
                    approvers:
                      userGroups:
                        - account._account_all_users
                      minimumCount: 1
                      disallowPipelineExecutor: false
                    approverInputs: []
                  timeout: 1d

              # Reuse steps from Dev stage (same pattern)
              - step:
                  type: ShellScript
                  name: Fetch Changelog Artifact
                  identifier: Fetch_Changelog_Artifact_Test
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e
                          echo "=== Fetching Changelog Artifact ==="
                          mkdir -p /tmp/changelog
                          cd /tmp/changelog
                          PACKAGE_URL="https://maven.pkg.github.com/<+pipeline.variables.GITHUB_ORG>/harness-gha-bagelstore/bagel-store-changelog/<+pipeline.variables.VERSION>/bagel-store-changelog-<+pipeline.variables.VERSION>.zip"
                          curl -L -H "Authorization: token <+secrets.getValue('github_pat')>" -o changelog.zip "$PACKAGE_URL"
                          unzip -q changelog.zip -d .
                          echo "Changelog extracted successfully"
                    environmentVariables: []
                    outputVariables: []
                  timeout: 5m

              - step:
                  type: ShellScript
                  name: Update Database
                  identifier: Update_Database_Test
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Updating Database with Liquibase ==="
                          echo "Environment: test"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use RDS via Secrets Manager
                            docker run --rm \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')> \
                              -e AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')> \
                              -e AWS_REGION=<+env.variables.aws_region> \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=<+env.variables.jdbc_url> \
                              --username='${awsSecretsManager:<+env.variables.demo_id>/rds/username}' \
                              --password='${awsSecretsManager:<+env.variables.demo_id>/rds/password}' \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          else
                            # LOCAL MODE - Use Docker Compose postgres containers
                            echo "Running Liquibase against local postgres-<+env.variables.environment> container"
                            docker run --rm \
                              --network harness-gha-bagelstore_bagel-network \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=jdbc:postgresql://postgres-<+env.variables.environment>:5432/<+env.variables.environment> \
                              --username=postgres \
                              --password=postgres \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          fi

                          echo "Database update completed successfully"
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Deploy Application
                  identifier: Deploy_Application_Test
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Deploying Application ==="
                          echo "Environment: test"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"
                          echo "New Version: <+pipeline.variables.VERSION>"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Deploy to App Runner
                            echo "Deploying to App Runner"
                            export AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')>
                            export AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')>
                            export AWS_DEFAULT_REGION=<+env.variables.aws_region>
                            SERVICE_ARN="<+env.variables.app_runner_service_arn>"

                            # Extract host and port from jdbc_url for DATABASE_URL construction
                            JDBC_URL="<+env.variables.jdbc_url>"
                            DB_HOST=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://([^:]+):.*|\1|')
                            DB_PORT=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://[^:]+:([0-9]+)/.*|\1|')
                            DB_NAME="<+env.variables.database_name>"

                            aws apprunner update-service \
                              --service-arn "$SERVICE_ARN" \
                              --source-configuration "{\"ImageRepository\":{\"ImageIdentifier\":\"ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:<+pipeline.variables.VERSION>\",\"ImageRepositoryType\":\"ECR_PUBLIC\",\"ImageConfiguration\":{\"Port\":\"5000\",\"RuntimeEnvironmentVariables\":{\"DATABASE_URL\":\"postgresql://\${awsSecretsManager:<+env.variables.demo_id>/rds/username}:\${awsSecretsManager:<+env.variables.demo_id>/rds/password}@$DB_HOST:$DB_PORT/$DB_NAME\",\"FLASK_ENV\":\"production\",\"APP_VERSION\":\"<+pipeline.variables.VERSION>\"}}}}" \
                              --region <+env.variables.aws_region>

                            echo "App Runner service update initiated"
                          else
                            # LOCAL MODE - Update .env and restart Docker Compose service
                            echo "Deploying to local Docker Compose"

                            # Determine environment variable name
                            ENV_NAME="<+env.variables.environment>"
                            ENV_VAR="VERSION_$(echo $ENV_NAME | tr '[:lower:]' '[:upper:]')"
                            NEW_VERSION="<+pipeline.variables.VERSION>"

                            # Navigate to repository root
                            cd $HOME/workspace/harness-gha-bagelstore

                            # Update .env file
                            echo "Updating .env: $ENV_VAR=$NEW_VERSION"
                            sed -i.bak "s/^${ENV_VAR}=.*/${ENV_VAR}=${NEW_VERSION}/" .env
                            rm -f .env.bak

                            # Pull new image
                            echo "Pulling new image: ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:$NEW_VERSION"
                            docker compose -f docker-compose-demo.yml pull app-<+env.variables.environment>

                            # Restart service
                            echo "Restarting app-<+env.variables.environment>"
                            docker compose -f docker-compose-demo.yml up -d --no-deps app-<+env.variables.environment>

                            echo "Local deployment completed"
                          fi
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Health Check
                  identifier: Health_Check_Test
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Performing Health Check ==="
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use App Runner service URL
                            SERVICE_URL="<+env.variables.app_runner_service_url>"
                            HEALTH_URL="https://${SERVICE_URL}/health"
                          else
                            # LOCAL MODE - Use localhost port mapping
                            case "<+env.variables.environment>" in
                              dev)     PORT=5001 ;;
                              test)    PORT=5002 ;;
                              staging) PORT=5003 ;;
                              prod)    PORT=5004 ;;
                              *)       echo "Unknown environment"; exit 1 ;;
                            esac
                            HEALTH_URL="http://localhost:${PORT}/health"
                          fi

                          echo "Health check URL: $HEALTH_URL"

                          MAX_ATTEMPTS=30
                          ATTEMPT=0

                          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

                            if [ "$HTTP_CODE" = "200" ]; then
                              echo "✅ Health check passed!"

                              # Verify version endpoint
                              VERSION_INFO=$(curl -s "${HEALTH_URL/health/version}" || echo "")
                              echo "Version info: $VERSION_INFO"

                              exit 0
                            fi

                            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS - HTTP $HTTP_CODE"
                            echo "Retrying in 10s..."
                            sleep 10
                            ATTEMPT=$((ATTEMPT + 1))
                          done

                          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
                          exit 1
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

            rollbackSteps: []

        failureStrategies:
          - onFailure:
              errors:
                - AllErrors
              action:
                type: Abort

        when:
          pipelineStatus: Success

    # ===== STAGE 3: Deploy to Staging (Manual Approval Required) =====
    - stage:
        name: Deploy to Staging
        identifier: Deploy_to_Staging
        description: Deploy database and application to staging environment (requires approval)
        type: Deployment
        tags:
          environment: staging

        spec:
          deploymentType: CustomDeployment

          service:
            useFromStage:
              stage: Deploy_to_Dev

          environment:
            environmentRef: staging
            deployToAll: false
            infrastructureDefinitions:
              - identifier: staging_infrastructure

          execution:
            steps:
              - step:
                  type: HarnessApproval
                  name: Approve Staging Deployment
                  identifier: Approve_Staging_Deployment
                  spec:
                    approvalMessage: "Please review and approve deployment to STAGING environment.\n\nVersion: <+pipeline.variables.VERSION>\nDemo ID: <+env.variables.demo_id>\n\nThis is the final pre-production environment."
                    includePipelineExecutionHistory: true
                    approvers:
                      userGroups:
                        - account._account_all_users
                      minimumCount: 1
                      disallowPipelineExecutor: false
                    approverInputs: []
                  timeout: 1d

              - step:
                  type: ShellScript
                  name: Fetch Changelog Artifact
                  identifier: Fetch_Changelog_Artifact_Staging
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e
                          echo "=== Fetching Changelog Artifact ==="
                          mkdir -p /tmp/changelog
                          cd /tmp/changelog
                          PACKAGE_URL="https://maven.pkg.github.com/<+pipeline.variables.GITHUB_ORG>/harness-gha-bagelstore/bagel-store-changelog/<+pipeline.variables.VERSION>/bagel-store-changelog-<+pipeline.variables.VERSION>.zip"
                          curl -L -H "Authorization: token <+secrets.getValue('github_pat')>" -o changelog.zip "$PACKAGE_URL"
                          unzip -q changelog.zip -d .
                    environmentVariables: []
                    outputVariables: []
                  timeout: 5m

              - step:
                  type: ShellScript
                  name: Update Database
                  identifier: Update_Database_Staging
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Updating Database with Liquibase ==="
                          echo "Environment: staging"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use RDS via Secrets Manager
                            docker run --rm \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')> \
                              -e AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')> \
                              -e AWS_REGION=<+env.variables.aws_region> \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=<+env.variables.jdbc_url> \
                              --username='${awsSecretsManager:<+env.variables.demo_id>/rds/username}' \
                              --password='${awsSecretsManager:<+env.variables.demo_id>/rds/password}' \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          else
                            # LOCAL MODE - Use Docker Compose postgres containers
                            echo "Running Liquibase against local postgres-<+env.variables.environment> container"
                            docker run --rm \
                              --network harness-gha-bagelstore_bagel-network \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=jdbc:postgresql://postgres-<+env.variables.environment>:5432/<+env.variables.environment> \
                              --username=postgres \
                              --password=postgres \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          fi

                          echo "Database update completed successfully"
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Deploy Application
                  identifier: Deploy_Application_Staging
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Deploying Application ==="
                          echo "Environment: staging"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"
                          echo "New Version: <+pipeline.variables.VERSION>"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Deploy to App Runner
                            echo "Deploying to App Runner"
                            export AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')>
                            export AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')>
                            export AWS_DEFAULT_REGION=<+env.variables.aws_region>
                            SERVICE_ARN="<+env.variables.app_runner_service_arn>"

                            # Extract host and port from jdbc_url for DATABASE_URL construction
                            JDBC_URL="<+env.variables.jdbc_url>"
                            DB_HOST=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://([^:]+):.*|\1|')
                            DB_PORT=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://[^:]+:([0-9]+)/.*|\1|')
                            DB_NAME="<+env.variables.database_name>"

                            aws apprunner update-service \
                              --service-arn "$SERVICE_ARN" \
                              --source-configuration "{\"ImageRepository\":{\"ImageIdentifier\":\"ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:<+pipeline.variables.VERSION>\",\"ImageRepositoryType\":\"ECR_PUBLIC\",\"ImageConfiguration\":{\"Port\":\"5000\",\"RuntimeEnvironmentVariables\":{\"DATABASE_URL\":\"postgresql://\${awsSecretsManager:<+env.variables.demo_id>/rds/username}:\${awsSecretsManager:<+env.variables.demo_id>/rds/password}@$DB_HOST:$DB_PORT/$DB_NAME\",\"FLASK_ENV\":\"production\",\"APP_VERSION\":\"<+pipeline.variables.VERSION>\"}}}}" \
                              --region <+env.variables.aws_region>

                            echo "App Runner service update initiated"
                          else
                            # LOCAL MODE - Update .env and restart Docker Compose service
                            echo "Deploying to local Docker Compose"

                            # Determine environment variable name
                            ENV_NAME="<+env.variables.environment>"
                            ENV_VAR="VERSION_$(echo $ENV_NAME | tr '[:lower:]' '[:upper:]')"
                            NEW_VERSION="<+pipeline.variables.VERSION>"

                            # Navigate to repository root
                            cd $HOME/workspace/harness-gha-bagelstore

                            # Update .env file
                            echo "Updating .env: $ENV_VAR=$NEW_VERSION"
                            sed -i.bak "s/^${ENV_VAR}=.*/${ENV_VAR}=${NEW_VERSION}/" .env
                            rm -f .env.bak

                            # Pull new image
                            echo "Pulling new image: ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:$NEW_VERSION"
                            docker compose -f docker-compose-demo.yml pull app-<+env.variables.environment>

                            # Restart service
                            echo "Restarting app-<+env.variables.environment>"
                            docker compose -f docker-compose-demo.yml up -d --no-deps app-<+env.variables.environment>

                            echo "Local deployment completed"
                          fi
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Health Check
                  identifier: Health_Check_Staging
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Performing Health Check ==="
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use App Runner service URL
                            SERVICE_URL="<+env.variables.app_runner_service_url>"
                            HEALTH_URL="https://${SERVICE_URL}/health"
                          else
                            # LOCAL MODE - Use localhost port mapping
                            case "<+env.variables.environment>" in
                              dev)     PORT=5001 ;;
                              test)    PORT=5002 ;;
                              staging) PORT=5003 ;;
                              prod)    PORT=5004 ;;
                              *)       echo "Unknown environment"; exit 1 ;;
                            esac
                            HEALTH_URL="http://localhost:${PORT}/health"
                          fi

                          echo "Health check URL: $HEALTH_URL"

                          MAX_ATTEMPTS=30
                          ATTEMPT=0

                          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

                            if [ "$HTTP_CODE" = "200" ]; then
                              echo "✅ Health check passed!"

                              # Verify version endpoint
                              VERSION_INFO=$(curl -s "${HEALTH_URL/health/version}" || echo "")
                              echo "Version info: $VERSION_INFO"

                              exit 0
                            fi

                            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS - HTTP $HTTP_CODE"
                            echo "Retrying in 10s..."
                            sleep 10
                            ATTEMPT=$((ATTEMPT + 1))
                          done

                          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
                          exit 1
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

            rollbackSteps: []

        failureStrategies:
          - onFailure:
              errors:
                - AllErrors
              action:
                type: Abort

        when:
          pipelineStatus: Success

    # ===== STAGE 4: Deploy to Production (Manual Approval Required) =====
    - stage:
        name: Deploy to Production
        identifier: Deploy_to_Production
        description: Deploy database and application to production environment (requires approval)
        type: Deployment
        tags:
          environment: prod

        spec:
          deploymentType: CustomDeployment

          service:
            useFromStage:
              stage: Deploy_to_Dev

          environment:
            environmentRef: prod
            deployToAll: false
            infrastructureDefinitions:
              - identifier: prod_infrastructure

          execution:
            steps:
              - step:
                  type: HarnessApproval
                  name: Approve Production Deployment
                  identifier: Approve_Production_Deployment
                  spec:
                    approvalMessage: "⚠️ PRODUCTION DEPLOYMENT\n\nPlease carefully review before approving deployment to PRODUCTION.\n\nVersion: <+pipeline.variables.VERSION>\nDemo ID: <+env.variables.demo_id>\n\nThis will apply database changes and deploy to production environment."
                    includePipelineExecutionHistory: true
                    approvers:
                      userGroups:
                        - account._account_all_users
                      minimumCount: 1
                      disallowPipelineExecutor: false
                    approverInputs: []
                  timeout: 1d

              - step:
                  type: ShellScript
                  name: Fetch Changelog Artifact
                  identifier: Fetch_Changelog_Artifact_Prod
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e
                          echo "=== Fetching Changelog Artifact ==="
                          mkdir -p /tmp/changelog
                          cd /tmp/changelog
                          PACKAGE_URL="https://maven.pkg.github.com/<+pipeline.variables.GITHUB_ORG>/harness-gha-bagelstore/bagel-store-changelog/<+pipeline.variables.VERSION>/bagel-store-changelog-<+pipeline.variables.VERSION>.zip"
                          curl -L -H "Authorization: token <+secrets.getValue('github_pat')>" -o changelog.zip "$PACKAGE_URL"
                          unzip -q changelog.zip -d .
                    environmentVariables: []
                    outputVariables: []
                  timeout: 5m

              - step:
                  type: ShellScript
                  name: Update Database
                  identifier: Update_Database_Prod
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Updating Database with Liquibase ==="
                          echo "Environment: prod"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use RDS via Secrets Manager
                            docker run --rm \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')> \
                              -e AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')> \
                              -e AWS_REGION=<+env.variables.aws_region> \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=<+env.variables.jdbc_url> \
                              --username='${awsSecretsManager:<+env.variables.demo_id>/rds/username}' \
                              --password='${awsSecretsManager:<+env.variables.demo_id>/rds/password}' \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          else
                            # LOCAL MODE - Use Docker Compose postgres containers
                            echo "Running Liquibase against local postgres-<+env.variables.environment> container"
                            docker run --rm \
                              --network harness-gha-bagelstore_bagel-network \
                              -v /tmp/changelog:/liquibase/changelog \
                              -e LIQUIBASE_LICENSE_KEY=<+secrets.getValue('liquibase_license_key')> \
                              liquibase/liquibase-secure:5.0.1 \
                              --url=jdbc:postgresql://postgres-<+env.variables.environment>:5432/<+env.variables.environment> \
                              --username=postgres \
                              --password=postgres \
                              --changeLogFile=changelog-master.yaml \
                              --log-level=INFO \
                              update
                          fi

                          echo "Database update completed successfully"
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Deploy Application
                  identifier: Deploy_Application_Prod
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Deploying Application ==="
                          echo "Environment: prod"
                          echo "Deployment Target: $DEPLOYMENT_TARGET"
                          echo "New Version: <+pipeline.variables.VERSION>"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Deploy to App Runner
                            echo "Deploying to App Runner"
                            export AWS_ACCESS_KEY_ID=<+secrets.getValue('aws_access_key_id')>
                            export AWS_SECRET_ACCESS_KEY=<+secrets.getValue('aws_secret_access_key')>
                            export AWS_DEFAULT_REGION=<+env.variables.aws_region>
                            SERVICE_ARN="<+env.variables.app_runner_service_arn>"

                            # Extract host and port from jdbc_url for DATABASE_URL construction
                            JDBC_URL="<+env.variables.jdbc_url>"
                            DB_HOST=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://([^:]+):.*|\1|')
                            DB_PORT=$(echo "$JDBC_URL" | sed -E 's|jdbc:postgresql://[^:]+:([0-9]+)/.*|\1|')
                            DB_NAME="<+env.variables.database_name>"

                            aws apprunner update-service \
                              --service-arn "$SERVICE_ARN" \
                              --source-configuration "{\"ImageRepository\":{\"ImageIdentifier\":\"ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:<+pipeline.variables.VERSION>\",\"ImageRepositoryType\":\"ECR_PUBLIC\",\"ImageConfiguration\":{\"Port\":\"5000\",\"RuntimeEnvironmentVariables\":{\"DATABASE_URL\":\"postgresql://\${awsSecretsManager:<+env.variables.demo_id>/rds/username}:\${awsSecretsManager:<+env.variables.demo_id>/rds/password}@$DB_HOST:$DB_PORT/$DB_NAME\",\"FLASK_ENV\":\"production\",\"APP_VERSION\":\"<+pipeline.variables.VERSION>\"}}}}" \
                              --region <+env.variables.aws_region>

                            echo "App Runner service update initiated"
                          else
                            # LOCAL MODE - Update .env and restart Docker Compose service
                            echo "Deploying to local Docker Compose"

                            # Determine environment variable name
                            ENV_NAME="<+env.variables.environment>"
                            ENV_VAR="VERSION_$(echo $ENV_NAME | tr '[:lower:]' '[:upper:]')"
                            NEW_VERSION="<+pipeline.variables.VERSION>"

                            # Navigate to repository root
                            cd $HOME/workspace/harness-gha-bagelstore

                            # Update .env file
                            echo "Updating .env: $ENV_VAR=$NEW_VERSION"
                            sed -i.bak "s/^${ENV_VAR}=.*/${ENV_VAR}=${NEW_VERSION}/" .env
                            rm -f .env.bak

                            # Pull new image
                            echo "Pulling new image: ghcr.io/<+pipeline.variables.GITHUB_ORG>/bagel-store:$NEW_VERSION"
                            docker compose -f docker-compose-demo.yml pull app-<+env.variables.environment>

                            # Restart service
                            echo "Restarting app-<+env.variables.environment>"
                            docker compose -f docker-compose-demo.yml up -d --no-deps app-<+env.variables.environment>

                            echo "Local deployment completed"
                          fi
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

              - step:
                  type: ShellScript
                  name: Health Check
                  identifier: Health_Check_Prod
                  spec:
                    shell: Bash
                    executionTarget: {}
                    source:
                      type: Inline
                      spec:
                        script: |-
                          #!/bin/bash
                          set -e

                          # Determine deployment target (defaults to aws if not set)
                          DEPLOYMENT_TARGET="${DEPLOYMENT_TARGET:-aws}"

                          echo "=== Performing Health Check ==="
                          echo "Deployment Target: $DEPLOYMENT_TARGET"

                          if [ "$DEPLOYMENT_TARGET" = "aws" ]; then
                            # AWS MODE - Use App Runner service URL
                            SERVICE_URL="<+env.variables.app_runner_service_url>"
                            HEALTH_URL="https://${SERVICE_URL}/health"
                          else
                            # LOCAL MODE - Use localhost port mapping
                            case "<+env.variables.environment>" in
                              dev)     PORT=5001 ;;
                              test)    PORT=5002 ;;
                              staging) PORT=5003 ;;
                              prod)    PORT=5004 ;;
                              *)       echo "Unknown environment"; exit 1 ;;
                            esac
                            HEALTH_URL="http://localhost:${PORT}/health"
                          fi

                          echo "Health check URL: $HEALTH_URL"

                          MAX_ATTEMPTS=30
                          ATTEMPT=0

                          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_URL" || echo "000")

                            if [ "$HTTP_CODE" = "200" ]; then
                              echo "✅ Production deployment successful!"

                              # Verify version endpoint
                              VERSION_INFO=$(curl -s "${HEALTH_URL/health/version}" || echo "")
                              echo "Version info: $VERSION_INFO"

                              echo "🎉 All environments now running version <+pipeline.variables.VERSION>"
                              exit 0
                            fi

                            echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS - HTTP $HTTP_CODE"
                            echo "Retrying in 10s..."
                            sleep 10
                            ATTEMPT=$((ATTEMPT + 1))
                          done

                          echo "❌ Health check failed after $MAX_ATTEMPTS attempts"
                          exit 1
                    environmentVariables: []
                    outputVariables: []
                  timeout: 10m

            rollbackSteps: []

        failureStrategies:
          - onFailure:
              errors:
                - AllErrors
              action:
                type: Abort

        when:
          pipelineStatus: Success

  # Allow individual stage execution
  allowStageExecutions: true
